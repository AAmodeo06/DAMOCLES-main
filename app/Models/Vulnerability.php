<?php
<<<<<<< Updated upstream
// Implementato da: Cosimo Mandrillo
=======

<<<<<<< Updated upstream
=======
// Implementato da: Cosimo Mandrillo

>>>>>>> Stashed changes
>>>>>>> Stashed changes
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Collection;

class Vulnerability extends Model
{
    protected $fillable = ['name', 'description'];

<<<<<<< Updated upstream
    // Relazione con human factors - Cosimo Mandrillo
=======
<<<<<<< Updated upstream
    protected $fillable = [
        'name',
        'description',
        'severity',
        'cve_id',
        'affected_systems',
        'patch_available',
        'exploitation_difficulty',
        'discovery_date',
    ];

    protected $casts = [
        'discovery_date' => 'datetime',
        'patch_available' => 'boolean',
        'affected_systems' => 'array',
    ];

    /**
     * Relazione con HumanFactor
     * @author Luigi La Gioia
     */
>>>>>>> Stashed changes
    public function humanFactors()
    {
        return $this->belongsToMany(HumanFactor::class, 'human_factor_vulnerability');
    }

<<<<<<< Updated upstream
    // Relazione con campagne - Cosimo Mandrillo
    public function trainingCampaigns()
=======
    /**
     * Scope per vulnerabilità critiche
     * @author Luigi La Gioia
     */
    public function scopeCritical($query)
=======
    public function humanFactors()
    {
        return $this->belongsToMany(HumanFactor::class, 'human_factor_vulnerability')
            ->withTimestamps();
    }

    public function trainingCampaigns()
>>>>>>> Stashed changes
>>>>>>> Stashed changes
    {
        return $this->hasMany(TrainingCampaign::class);
    }

<<<<<<< Updated upstream
    // Ottieni utenti vulnerabili - Cosimo Mandrillo
    public function getVulnerableUsers($minScore = 3)
=======
<<<<<<< Updated upstream
    /**
     * Scope per vulnerabilità senza patch
     * @author Luigi La Gioia
     */
    public function scopeUnpatched($query)
>>>>>>> Stashed changes
    {
        $hfIds = $this->humanFactors->pluck('id');

<<<<<<< Updated upstream
        return User::whereHas('humanFactors', function($query) use ($hfIds, $minScore) {
            $query->whereIn('hf_id', $hfIds)
                  ->where('score', '>=', $minScore);
        })->get();
=======
    /**
     * Calcola il risk score della vulnerabilità
     * @author Luigi La Gioia
     */
    public function calculateRiskScore()
    {
        $severityScores = [
            'low' => 25,
            'medium' => 50,
            'high' => 75,
            'critical' => 100
        ];

        $baseScore = $severityScores[$this->severity] ?? 50;

        if (!$this->patch_available) {
            $baseScore *= 1.3;
        }

        $difficultyMultiplier = [
            'easy' => 1.2,
            'medium' => 1.0,
            'hard' => 0.8
        ];

        $baseScore *= ($difficultyMultiplier[$this->exploitation_difficulty] ?? 1.0);

        return min(100, round($baseScore));
=======
    public function getVulnerableUsers(string $minLevel = 'medium'): Collection
    {
        $rank = ['none'=>0,'low'=>1,'medium'=>2,'high'=>3,'max'=>4];
        $minLevel = strtolower($minLevel);
        if (!array_key_exists($minLevel, $rank)) $minLevel = 'medium';
        $allowed = array_keys(array_filter($rank, fn($v) => $v >= $rank[$minLevel]));

        $hfIds = $this->humanFactors()->pluck('human_factors.id')->all();
        if (empty($hfIds)) return new Collection();

        return User::whereHas('humanFactors', function ($q) use ($hfIds, $allowed) {
                $q->whereIn('human_factors.id', $hfIds)
                  ->whereIn('user_human_factor.debt_level', $allowed);
            })
            ->get();
>>>>>>> Stashed changes
>>>>>>> Stashed changes
    }
}
